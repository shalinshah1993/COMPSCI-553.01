structure A = Absyn
open Symbol
%%
%term EOF 
	| ID of string
	| INT of int | STRING of string 
	| COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK 
	| LBRACE | RBRACE | DOT 
	| PLUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE | UMINUS
	| AND | OR | ASSIGN
	| ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF 
	| BREAK | NIL
	| FUNCTION | VAR | TYPE 

%nonterm  program of A.exp 			(* DONE *)
		| exp of A.exp 				(* DONE *)
		| lValue of A.var 			(* DONE *)
		| lValue_tail of A.exp
		| arithmeticExp of A.exp 	(* DONE *)
		| compExp of A.exp 			(* DONE *)
		| boolExp of A.exp 			(* DONE *)
		| noValExp of A.exp 		(* DONE *)
		| condExp of A.exp 			(* DONE *)
		| expSeq of A.SeqExp 		(* DONE *)
		| funcCall of A.CallExp 		(* DONE *)
		| paraList of A.exp list	(* DONE *)
		| decs of A.dec list		(* DONE *)
		| dec of A.dec 				(* DONE *)
		| typeDec of A.TypeDec			(* DONE *)
		| typeDecList of A.TypeDec list	(* DONE *)
		| ty of A.ty
		| tyField
		| tyFields
		| varDec
		| funcDec
		| createArray
		| createRecord
		| recordList
		| recordField

%name Shah_Lynch_Parser
%pos int
%verbose

%start program
%eop EOF
%noshift EOF

(* Reserved keyword for the Tiger language *)
%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE DO OF NIL
(* Used to insert in Tiger *)
%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

(* Precedence in the reverse order *)
%nonassoc ASSIGN THEN OF DO
%right ELSE
%left AND OR
%nonassoc EQ NEQ LT LE GT GE
%left PLUS MINUS
%left TIMES DIVIDE
%left UMINUS

%%

program	: 
			exp							(exp)		

(* CFG for declaring an expression *)
exp : 	
		NIL								(A.NilExp)
	|	INT 							(A.IntExp INT)
	|	STRING 							(A.StringExp(STRING, STRINGleft))
	|	BREAK							(A.BreakExp(BREAKleft))
	|	lValue							(A.VarExp(lValue))
	|	arithmeticExp					(arithmeticExp)
	|	compExp							(compExp)
	|	boolExp							(boolExp)
	|	noValExp						(noValExp)
	|	condExp							(condExp)
	|	funcCall						(funcCall)
	|	LET decs IN expSeq END 			(A.LetExp {decs=decs, body=A.SeqExp(expSeq), pos=LETleft})
	|	LPAREN expSeq RPAREN 			(A.SeqExp(expSeq))
	|	createArray						(createArray)
	|	createRecord					(createRecord)
	|	lValue ASSIGN exp 				(A.AssignExp {var=lvalue, exp=exp, pos=lValueleft})



lValue :
		ID								(A.SimpleVar(symbol ID, IDleft))
	|	ID lValue_tail					()
	
lValue_tail :
		DOT ID							()
	|	LBRACK exp RBRACK				()
		

(* CFG for different exp evaluation *)
arithmeticExp :	
		exp TIMES exp 					(A.OpExp {left=exp1, oper=A.TimesOp, right=exp2, pos=exp1left})
	|	exp DIVIDE exp 					(A.OpExp {left=exp1, oper=A.DivideOp, right=exp2, pos=exp1left})
	|	exp PLUS exp 					(A.OpExp {left=exp1, oper=A.PlusOp, right=exp2, pos=exp1left})
	|	exp MINUS exp 					(A.OpExp {left=exp1, oper=A.MinusOp, right=exp2, pos=exp1left})
	|	MINUS exp %prec UMINUS 			(A.OpExp ({left = A.IntExp(0), oper = A.MinusOp, right = exp, pos = pos}))

compExp :
		exp EQ exp 						(A.OpExp {left=exp1, oper=A.EqOp, right=exp2, pos=exp1left})
	|	exp NEQ exp 					(A.OpExp {left=exp1, oper=A.NeqOp, right=exp2, pos=exp1left})
	| 	exp GT exp 						(A.OpExp {left=exp1, oper=A.GtOp, right=exp2, pos=exp1left})
	|	exp GE exp 						(A.OpExp {left=exp1, oper=A.GeOp, right=exp2, pos=exp1left})
	|	exp LT exp 						(A.OpExp {left=exp1, oper=A.LtOp, right=exp2, pos=exp1left})
	| 	exp LE exp 						(A.OpExp {left=exp1, oper=A.LeOp, right=exp2, pos=exp1left})

boolExp :
		exp AND exp 					(A.IfExp {test=exp1, then'=exp2, else'=SOME(A.IntExp(0)), pos=exp1left})
	|	exp OR exp 						(A.IfExp {test=exp1, then'=A.IntExp(1), else'=SOME(exp2), pos=exp1left})
		
condExp :
		IF exp THEN exp ELSE exp        (A.IfExp {test=exp1, then'=exp2, else'=SOME(exp3), pos=IFleft})
	| 	IF exp THEN exp                 (A.IfExp {test=exp1, then'=exp2, else'=NONE, pos=IFleft})
	| 	WHILE exp DO exp                (A.WhileExp {test=exp1, body=exp2, pos=WHILEleft})
	|	FOR ID ASSIGN exp TO exp DO exp (A.ForExp {var=symbol ID, escape= ref true, lo=exp1, hi=exp2, body=exp3, pos=FORleft})
		

noValExp :
		LPAREN RPAREN					(A.NilExp)

expSeq :
		exp 				 			([exp, expleft])
	|	expSeq SEMICOLON exp 			(expSeq @ [(exp, expleft)])

(* CFG to call a function and it's parameter list *)
funcCall :
		ID LPAREN paraList RPAREN		(A.CallExp{func=symbol ID, args=paraList, pos=IDleft})

paraList :
										([])
	|	exp 							([exp])
	|	paraList COMMA exp 				(paraList @ [exp])

(* CFG for declaring data type *)
decs :
										([])
	|	decs dec 						(decs @ [dec])

dec :
		typeDecList						(A.TypeDec typeDecList)
	|	varDec 							(varDec)
	|	funcDec 						(funcDec)

typeDecList : 
			typeDec 					([typeDec])
		|	tydeclist typeDec 			(typeDecList @ [typeDec])

typeDec :  
		TYPE ID EQ ty 					({name=symbol ID, ty=ty, pos=TYPEleft})

ty : 
		ID                        		(A.NameTy (symbol ID, IDleft))
  	| 	LBRACE tyFields RBRACE    		(A.RecordTy tyFields)
  	| 	ARRAY OF ID               		(A.ArrayTy (symbol ID, ARRAYleft))

(* CFG for list of types associated with an ID: Used as funPar and defining list data type *)
tyFields :
										([])
    |	tyField 						([tyField])
	|	tyFields COMMA tyField 			(tyField)

tyField : 
		ID COLON ID          			(A.field {name=symbol ID1, escape=ref true, typ=symbol ID2, pos=ID1left})

(* CFG for decalaring a variables *)
varDec : 
		VAR ID ASSIGN exp               ()
	|	VAR ID COLON ID ASSIGN exp      ()

(* CFG for declaring a function *)
funcDec : 
		FUNCTION ID LPAREN tyfields RPAREN EQ exp       	()
	|	FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ exp  ()

(* CFG for array creation *)
createArray : 
				ID LBRACK exp RBRACK OF exp        ()

(* CFG for record creation *)
createRecord : 
				ID LBRACE recordList RBRACE      ()

recordList :    
                        							    ()
  					|	recordField                     ()
  					|	recordList COMMA recordField    ()

recordField :
				ID EQ exp         ()
		