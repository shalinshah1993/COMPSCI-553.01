%%


%term EOF 
	| ID of string
	| INT of int | STRING of string 
	| COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK 
	| LBRACE | RBRACE | DOT 
	| PLUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE | UMINUS
	| AND | OR | ASSIGN
	| ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF 
	| BREAK | NIL
	| FUNCTION | VAR | TYPE 

%nonterm  program
		| statement
		| exp
		| lValue
		| arithmeticExp
		| compExp
		| boolExp
		| noValExp
		| condExp
		| expSeq
		| funcCall
		| paraList
		| decs
		| dec
		| typeDec
		| ty
		| tyfield
		| tyfields
		| varDec
		| funcDec
		| createArray
		| createRecord
		| recordList
		| recordField

%name Shah_Lynch_Parser
%pos int
%verbose

%start program
%eop EOF
%noshift EOF

(* Reserved keyword for the Tiger language *)
%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE DO OF NIL
(* Used to insert in Tiger *)
%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

(* Precedence in the reverse order *)
%nonassoc ASSIGN THEN OF DO
%right ELSE
%left AND OR
%nonassoc EQ NEQ LT LE GT GE
%left PLUS MINUS
%left TIMES DIVIDE
%left UMINUS

%%

program	: 
			exp			()		

(* CFG for declaring an expression *)
exp : 	
		NIL								()
	|	INT 							()
	|	STRING 							()
	|	BREAK							()
	|	lValue							()
	|	arithmeticExp					()
	|	compExp							()
	|	boolExp							()
	|	noValExp						()
	|	condExp							()
	|	funcCall						()
	|	LET decs IN expSeq END 			()
	|	createArray						()
	|	createRecord					()
	|	lValue ASSIGN exp 				()



lValue :
			ID							()
		|	lValue DOT ID				()
		|	lValue LBRACK exp RBRACK	()

(* CFG for different exp evaluation *)
arithmeticExp :	
				exp TIMES exp 			()
			|	exp DIVIDE exp 			()
			|	exp PLUS exp 			()
			|	exp MINUS exp 			()
			|	MINUS exp %prec UMINUS 	()

compExp :
			exp EQ exp 				()
		|	exp NEQ exp 			()
		| 	exp GT exp 				()
		|	exp GE exp 				()
		|	exp LT exp 				()
		| 	exp LE exp 				()

boolExp :
			exp AND exp 			()
		|	exp OR exp 				()
		
condExp :
			IF exp THEN exp ELSE exp        ()
		| 	IF exp THEN exp                 ()
		| 	WHILE exp DO exp                ()
		|	FOR ID ASSIGN exp TO exp DO exp ()
		

noValExp :
			LPAREN RPAREN			()

expSeq :
			LPAREN expSeq RPAREN 			()
		|	expSeq SEMICOLON exp 			()

(* CFG to call a function and it's parameter list *)
funcCall :
			ID LPAREN paraList RPAREN	()

paraList :
										()
		|	exp 						()
		|	paraList COMMA exp 			()

(* CFG for declaring data type *)
decs :
								()
	|	decs dec 				()

dec :
		typeDec					()
	|	varDec 					()
	|	funcDec 				()

typeDec :  
		TYPE ID EQ ty 			()

ty : 
		ID                        ()
  	| 	LBRACE tyfields RBRACE    ()
  	| 	ARRAY OF ID               ()

(* CFG for list of types associated with an ID: Used as funPar and defining list data type *)
tyfields :
                           				()
        |	tyfield 					()
  		|	tyfields COMMA tyfield 		()

tyfield : 
			ID COLON ID          ()

(* CFG for decalaring a variables *)
varDec : 
			VAR ID ASSIGN exp                  ()
		|	VAR ID COLON ID ASSIGN exp         ()

(* CFG for declaring a function *)
funcDec : 
			FUNCTION ID LPAREN tyfields RPAREN EQ exp       	()
		|	FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ exp  ()

(* CFG for array creation *)
createArray : 
				ID LBRACK exp RBRACK OF exp        ()

(* CFG for record creation *)
createRecord : 
				ID LBRACE recordList RBRACE      ()

recordList :    
                        							    ()
  					|	recordField                     ()
  					|	recordList COMMA recordField    ()

recordField :
				ID EQ exp         ()
		